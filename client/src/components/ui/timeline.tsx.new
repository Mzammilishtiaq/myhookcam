import { useRef, useEffect, useState } from "react";
import { 
  AlertTriangle, Loader2, ZoomIn, ZoomOut, Bookmark, MessageSquare,
  FileDown, BookmarkPlus, FileEdit, Share2, Flag
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
// Removed Select imports as we simplified the export UI
import { VideoPreview } from "@/components/ui/video-preview";
import type { Clip, NoteFlag } from "@shared/schema";
import { useNotesFlags } from "@/hooks/use-notes-flags";
import { useToast } from "@/hooks/use-toast";
import { formatVideoTime } from "@/lib/time";
import { ShareModal } from "@/components/ui/share-modal";
import { NoteFlagModal } from "@/components/ui/note-flag-modal";

interface TimelineProps {
  clips: Clip[];
  currentClip?: Clip;
  isLoading: boolean;
  isError: boolean;
  onSelectClip: (clip: Clip) => void;
  onExportCurrentClip: () => void;
  selectedDate: string;
}

// Smart zoom level presets
type ZoomPreset = {
  id: string;
  label: string;
  level: number;
  focus: number | null; // null means no specific focus
  description: string;
};

const ZOOM_PRESETS: ZoomPreset[] = [
  {
    id: 'working-hours',
    label: 'Working Hours',
    level: 2,
    focus: 11, // Mid-morning as focus point
    description: 'Focus on 06:30-17:30 working hours'
  },
  // No additional presets - only the working hours preset
];

export function Timeline({
  clips,
  currentClip,
  isLoading,
  isError,
  onSelectClip,
  onExportCurrentClip,
  selectedDate
}: TimelineProps) {
  const timelineRef = useRef<HTMLDivElement>(null);
  const [zoomLevel, setZoomLevel] = useState<number>(2); // Default zoom level - zoomed in for working hours
  const [focusHour, setFocusHour] = useState<number>(11); // Default focus centered on the working day
  const [activePreset, setActivePreset] = useState<string>('working-hours'); // Default preset
  const [hoveredSegment, setHoveredSegment] = useState<string | null>(null); // Track hovered segment by time key
  const [previewPosition, setPreviewPosition] = useState<number>(50); // Position within clip (as percentage)
  const [mousePosition, setMousePosition] = useState<{x: number, y: number}>({x: 0, y: 0}); // Track mouse position for preview
  // Removed dropdown states for export options
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const [isNoteFlagModalOpen, setIsNoteFlagModalOpen] = useState(false);
  const { toast } = useToast();
  
  // Fetch notes and flags for the selected date
  const { 
    notesFlags = [], 
    flags = [], 
    notes = [], 
    createNoteFlag 
  } = useNotesFlags(selectedDate);
  
  // Generate segments for a 24-hour timeline with emphasis on working hours (07:00-17:00)
  // Each segment represents a 5-minute interval (288 segments in a day)
  const hourMarkers = Array.from({ length: 24 }, (_, i) => {
    const hour = i;
    const label = `${hour.toString().padStart(2, '0')}:00`;
    const isWorkingHour = hour >= 7 && hour <= 17; // 07:00 to 17:00
    
    return {
      hour,
      label,
      position: (hour / 24) * 100,
      isWorkingHour
    };
  });
  
  // Helper function to find notes and flags for a segment
  const findItemsForSegment = (clipTime: string) => {
    // Find items for this segment
    const segmentItems = notesFlags.filter((item: NoteFlag) => {
      // Check if the clipTime matches the segment
      return item.clipTime === clipTime;
    });
    
    // Find notes (any item with content)
    const segmentNotes = segmentItems.filter(item => item.content);
    
    // Find flags (items where isFlag is true)
    const segmentFlags = segmentItems.filter(item => item.isFlag);
    
    return {
      notesFlags: segmentItems,
      notes: segmentNotes,
      flags: segmentFlags,
      hasNotes: segmentNotes.length > 0,
      hasFlags: segmentFlags.length > 0
    };
  };
  
  // Find clip by clipTime for jumping to a specific time
  const findClipByTime = (clipTime: string): Clip | undefined => {
    return clips.find(clip => clip.startTime === clipTime);
  };
  
  // Generate time segments map for the entire day
  const generateTimeSegments = () => {
    // Create a map to track which 5-minute segments have clips
    const segmentMap = new Map<string, Clip>();
    
    // Populate map with available clips
    clips.forEach(clip => {
      // Extract hour and minute from clip start time (format: HH:MM)
      const [hours, minutes] = clip.startTime.split(':').map(Number);
      
      // Calculate segment key (HH:MM format)
      const segmentKey = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      
      // Store clip in the map
      segmentMap.set(segmentKey, clip);
    });
    
    // Generate all 288 5-minute segments for a 24-hour day
    const segments = [];
    
    for (let hour = 0; hour < 24; hour++) {
      const isWorkingHour = hour >= 7 && hour <= 17; // 07:00 to 17:00
      
      for (let minute = 0; minute < 60; minute += 5) {
        const timeKey = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        const displayTime = formatTimeDisplay(hour, minute);
        
        // Find notes and flags for this segment
        const { hasNotes, hasFlags, notes: segmentNotes, flags: segmentFlags } = findItemsForSegment(timeKey);
        
        segments.push({
          time: timeKey,
          displayTime,
          hasClip: segmentMap.has(timeKey),
          clip: segmentMap.get(timeKey),
          isCurrent: currentClip && currentClip.startTime === timeKey,
          isWorkingHour,
          hasNotes,
          hasFlags,
          notes: segmentNotes,
          flags: segmentFlags
        });
      }
    }
    
    return segments;
  };
  
  // Format time for display (24-hour format)
  const formatTimeDisplay = (hour: number, minute: number) => {
    return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
  };
  
  // Generate all timeline segments
  const timeSegments = generateTimeSegments();
  
  // Scroll to current clip when it changes
  useEffect(() => {
    if (currentClip && timelineRef.current) {
      // Find the segment index for the current clip
      const segmentIndex = timeSegments.findIndex(
        segment => segment.time === currentClip.startTime
      );
      
      if (segmentIndex !== -1) {
        // Calculate position to scroll to
        const segmentWidth = timelineRef.current.scrollWidth / timeSegments.length;
        const scrollPosition = segmentIndex * segmentWidth - timelineRef.current.clientWidth / 2;
        
        timelineRef.current.scrollTo({
          left: scrollPosition,
          behavior: 'smooth'
        });
      }
    }
  }, [currentClip]);
  
  // Calculate width for each segment - adjust based on zoom level
  const baseSegmentWidth = 0.5; // Base percentage width (increased from 0.35)
  const segmentWidth = baseSegmentWidth * zoomLevel;
  
  // Filter segments based on focus hour and zoom level
  const getVisibleSegments = () => {
    // For zoom level 1, show all segments
    if (zoomLevel <= 1) {
      return timeSegments;
    }
    
    // For higher zoom levels, focus on segments around the focus hour
    // The range narrows as zoom level increases
    const rangeSize = Math.max(4, 24 / zoomLevel);
    const startHour = Math.max(0, focusHour - rangeSize / 2);
    const endHour = Math.min(24, focusHour + rangeSize / 2);
    
    return timeSegments.filter(segment => {
      const [hours] = segment.time.split(':').map(Number);
      return hours >= startHour && hours < endHour;
    });
  };
  
  const visibleSegments = getVisibleSegments();
  
  // Handle zoom in/out
  const handleZoomIn = () => {
    setZoomLevel(prev => Math.min(prev + 0.5, 4)); // Max zoom level is 4x
  };
  
  const handleZoomOut = () => {
    setZoomLevel(prev => Math.max(prev - 0.5, 1)); // Min zoom level is 1x
    if (zoomLevel <= 1.5) {
      // When zooming out to near default, reset to full day preset
      setActivePreset('full-day');
    } else {
      // Otherwise, indicate custom zoom
      setActivePreset('custom');
    }
  };
  
  // Handle focus hour change
  const handleFocusChange = (value: number[]) => {
    setFocusHour(value[0]);
  };
  
  return (
    <div className="timeline-container mt-4">
      <div className="flex items-center mb-1">
        <h2 className="text-lg font-medium text-[#555555]">Timeline - Working Hours (07:00-17:00)</h2>
        
        <div className="ml-auto flex flex-wrap gap-2 text-xs">
          <div className="flex items-center">
            <div className="w-2 h-2 bg-[#FBBC05] rounded-full mr-1"></div>
            <span className="text-[#555555]">Available</span>
          </div>
          <div className="flex items-center">
            <div className="w-2 h-2 bg-[#ff9900] rounded-full mr-1"></div>
            <span className="text-[#555555]">Bookmarks</span>
          </div>
          <div className="flex items-center">
            <div className="w-2 h-2 bg-[#ffa833] rounded-full mr-1"></div>
            <span className="text-[#555555]">Notes</span>
          </div>
          <div className="flex items-center">
            <div className="w-2 h-2 bg-gradient-to-tr from-[#FBBC05] to-[#ff9900] rounded-full mr-1"></div>
            <span className="text-[#555555]">Both</span>
          </div>
          <div className="flex items-center">
            <div className="w-2 h-2 bg-[#555555] rounded-full mr-1"></div>
            <span className="text-[#555555]">No Footage</span>
          </div>
        </div>
      </div>
      
      {isLoading ? (
        <div className="flex items-center justify-center h-24 bg-[#FFFFFF] rounded-lg shadow border border-[#BCBBBB]">
          <Loader2 className="h-8 w-8 text-[#FBBC05] animate-spin" />
          <span className="ml-2 text-[#555555]">Loading clips...</span>
        </div>
      ) : isError ? (
        <div className="flex items-center justify-center h-24 bg-[#FFFFFF] rounded-lg shadow border border-[#BCBBBB]">
          <AlertTriangle className="h-8 w-8 text-[#555555]" />
          <span className="ml-2 text-[#555555]">Error loading timeline data</span>
        </div>
      ) : (
        <div className="timeline-scroll-container overflow-x-scroll bg-[#FFFFFF] rounded-lg shadow border border-[#BCBBBB] h-[80px] flex-1 relative" style={{
          scrollbarWidth: 'auto',
          scrollbarColor: '#BCBBBB #FFFFFF',
          overflowY: 'hidden',
          paddingBottom: '25px',
          paddingTop: '5px',
          marginBottom: '10px',
          paddingRight: '25px'
        }}>
          <div 
            ref={timelineRef}
            className="timeline-wrapper relative p-1 pt-0"
            style={{ width: "150%" }}
          >
            {/* Hour markers - filter based on zoom level */}
            <div className="hour-markers relative h-5">
              {hourMarkers
                .filter(marker => {
                  if (zoomLevel <= 1) return true;
                  const rangeSize = Math.max(4, 24 / zoomLevel);
                  const startHour = Math.max(0, focusHour - rangeSize / 2);
                  const endHour = Math.min(24, focusHour + rangeSize / 2);
                  return marker.hour >= startHour && marker.hour < endHour;
                })
                .map((marker) => (
                  <div 
                    key={marker.hour}
                    className={`hour-marker absolute border-l ${
                      marker.isWorkingHour ? 'border-[#555555] border-l-2' : 'border-[#BCBBBB]'
                    }`}
                    style={{ 
                      left: zoomLevel <= 1 
                        ? `${marker.position}%` 
                        : `${(marker.hour - Math.max(0, focusHour - Math.max(4, 24 / zoomLevel) / 2)) / Math.min(24, Math.max(4, 24 / zoomLevel)) * 100}%` 
                    }}
                    data-hour={marker.label}
                  >
                    <div className={`absolute top-3 transform -translate-x-1/2 text-xs font-mono ${
                      marker.isWorkingHour ? 'text-[#555555] font-bold' : 'text-[#BCBBBB]'
                    }`}>
                      {marker.label}
                    </div>
                  </div>
                ))}
            </div>
            
            {/* Timeline segments */}
            <div className="timeline-segments flex h-5 mt-4">
              {visibleSegments.map((segment, index) => (
                <div
                  key={index}
                  className={`timeline-segment hover:opacity-80 transition-opacity relative group
                    ${segment.hasClip 
                      ? segment.hasFlags && segment.hasNotes 
                        ? 'bg-gradient-to-tr from-[#FBBC05] to-[#ff9900] border border-[#000000]/20' 
                        : segment.hasFlags 
                          ? 'bg-[#ff9900] border border-[#000000]/20'
                          : segment.hasNotes
                            ? 'bg-[#ffa833] border border-[#000000]/20'
                            : 'bg-[#FBBC05] border border-[#000000]/20'
                      : 'bg-[#555555]'
                    } ${
                      segment.isCurrent ? 'ring-2 ring-[#000000]' : ''
                    } ${
                      segment.isWorkingHour ? 'h-5' : 'h-4 mt-1'
                    }`}
                  style={{ width: `${segmentWidth}%` }}
                  title={segment.displayTime}
                  onClick={() => {
                    if (segment.hasClip && segment.clip) {
                      onSelectClip(segment.clip);
                      // Auto-play when a clip is selected
                      // Note: Play state is managed by the parent component
                    }
                  }}
                  onMouseEnter={(e) => {
                    // Always set hovered segment for feedback, regardless of clip presence
                    setHoveredSegment(segment.time);
                    
                    // Calculate relative position in segment (0-100%)
                    const rect = e.currentTarget.getBoundingClientRect();
                    const relativeX = e.clientX - rect.left;
                    const percentage = (relativeX / rect.width) * 100;
                    setPreviewPosition(percentage);
                    
                    // Update mouse position for preview positioning
                    setMousePosition({
                      x: e.clientX,
                      y: e.clientY
                    });
                  }}
                  onMouseMove={(e) => {
                    if (hoveredSegment === segment.time) {
                      // Update position on mouse move
                      const rect = e.currentTarget.getBoundingClientRect();
                      const relativeX = e.clientX - rect.left;
                      const percentage = (relativeX / rect.width) * 100;
                      setPreviewPosition(percentage);
                      
                      // Update mouse position for preview positioning
                      setMousePosition({
                        x: e.clientX,
                        y: e.clientY
                      });
                    }
                  }}
                  onMouseLeave={() => {
                    setHoveredSegment(null);
                  }}
                >
                  {segment.isCurrent && (
                    <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-1 bg-[#000000] text-[#FFFFFF] px-2 py-1 rounded text-xs font-mono whitespace-nowrap">
                      Now Playing
                    </div>
                  )}
                  {zoomLevel >= 2.5 && (
                    <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-1 text-[#555555] text-xs font-mono whitespace-nowrap">
                      {segment.displayTime}
                    </div>
                  )}
                  
                  {/* Show notification dots for notes and flags at higher zoom levels */}
                  {segment.hasClip && segment.hasNotes && zoomLevel >= 3 && (
                    <div className="absolute top-[-5px] right-[3px] w-[5px] h-[5px] bg-[#ffa833] rounded-full"></div>
                  )}
                  {segment.hasClip && segment.hasFlags && zoomLevel >= 3 && (
                    <div className="absolute top-[-5px] right-[-2px] w-[5px] h-[5px] bg-[#ff9900] rounded-full"></div>
                  )}
                  
                  {/* Show expanded detail view for notes and flags */}
                  {zoomLevel >= 3 && segment.hasClip && (segment.hasNotes || segment.hasFlags) && (
                    <div className="absolute opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-[#FFFFFF] border border-[#BCBBBB] rounded p-1 shadow-lg z-10 w-[200px] max-h-[150px] overflow-y-auto"
                         style={{
                           top: "30px",
                           left: "50%",
                           transform: "translateX(-50%)"
                         }}>
                      {segment.flags.map((noteFlag: NoteFlag, i: number) => (
                        <div key={`flag-${i}`} className="mb-1 pb-1 border-b border-[#BCBBBB] last:border-b-0">
                          <div className="flex items-center">
                            <Flag className="h-3 w-3 text-[#ff9900] mr-1" /> 
                            <span className="text-xs text-[#555555] truncate">
                              Flagged at {noteFlag.clipTime}
                            </span>
                          </div>
                          {noteFlag.content && (
                            <p className="text-xs text-[#555555] ml-4">{noteFlag.content}</p>
                          )}
                        </div>
                      ))}
                      {segment.notes.map((noteFlag: NoteFlag, i: number) => (
                        <div key={`note-${i}`} className="mb-1 pb-1 border-b border-[#BCBBBB] last:border-b-0">
                          <div className="flex items-center">
                            <MessageSquare className="h-3 w-3 text-[#ffa833] mr-1" /> 
                            <span className="text-xs text-[#555555] truncate">
                              Note at {noteFlag.clipTime}
                            </span>
                          </div>
                          <p className="text-xs text-[#555555] ml-4">{noteFlag.content}</p>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
          
          {/* Video preview on hover - uses VideoPreview component */}
          {hoveredSegment && timeSegments.find(s => s.time === hoveredSegment)?.hasClip && (
            <VideoPreview 
              clip={timeSegments.find(s => s.time === hoveredSegment)?.clip!}
              position={previewPosition}
              mouseX={mousePosition.x}
              mouseY={mousePosition.y}
            />
          )}
        </div>
      )}
      
      {/* Timeline controls - zoom and focus */}
      <div className="timeline-controls w-full">
        <div className="flex items-center justify-between mb-2">
          <div className="flex items-center">
            <Button 
              variant="outline" 
              size="icon" 
              className="mr-2 bg-[#FFFFFF] border-[#BCBBBB] hover:bg-[#EEEEEE]"
              onClick={handleZoomOut}
              disabled={zoomLevel <= 1}
            >
              <ZoomOut className="h-4 w-4 text-[#555555]" />
            </Button>
            <Button 
              variant="outline" 
              size="icon"
              className="mr-2 bg-[#FFFFFF] border-[#BCBBBB] hover:bg-[#EEEEEE]"
              onClick={handleZoomIn}
              disabled={zoomLevel >= 4}
            >
              <ZoomIn className="h-4 w-4 text-[#555555]" />
            </Button>
            
            {/* Zoom level indicator/slider */}
            <div className="relative ml-2 w-[200px]">
              <Slider
                value={[focusHour]}
                min={0}
                max={23}
                step={1}
                onValueChange={handleFocusChange}
                disabled={zoomLevel <= 1}
                className={zoomLevel <= 1 ? 'opacity-50' : ''}
              />
            </div>
          </div>
          
          {/* Zoom information display */}
          <div className="text-xs text-[#555555] ml-2">
            <div className="flex items-center">
              <span className="font-mono">
                {zoomLevel > 1 ? (
                  <span>
                    Focus: {focusHour.toString().padStart(2, '0')}:00 | {zoomLevel.toFixed(1)}x
                  </span>
                ) : (
                  <span>Full Day View</span>
                )}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}